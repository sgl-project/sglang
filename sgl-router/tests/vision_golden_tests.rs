//! Golden tests for vision processors.
//!
//! These tests compare Rust preprocessor output against golden outputs
//! generated by HuggingFace transformers to ensure pixel-perfect compatibility.
//!
//! Two modes are tested:
//! - `llava/` - Standard CLIP processing (llava-hf/* models, no expand-to-square)
//! - `llava_pad/` - Expand-to-square mode (liuhaotian/llava-* models, image_aspect_ratio=pad)
//!
//! To regenerate golden outputs:
//! ```bash
//! python scripts/generate_vision_golden.py
//! ```

use std::fs::File;
use std::io::Read;
use std::path::Path;

use ndarray::Array4;
use sgl_model_gateway::multimodal::vision::{
    ImagePreProcessor, LlavaProcessor, PreProcessorConfig,
};

/// Load a numpy .npz file and extract pixel_values
fn load_golden_npz(path: &Path) -> Array4<f32> {
    let file = File::open(path).expect("Failed to open golden file");
    let mut npz = npyz::npz::NpzArchive::new(file).expect("Failed to parse npz");

    // Read pixel_values array (npz stores arrays without .npy extension in the lookup)
    let reader = npz
        .by_name("pixel_values")
        .expect("Failed to read npz")
        .expect("No pixel_values");

    // Get shape from npy header
    let shape = reader.shape().to_vec();
    assert_eq!(shape.len(), 4, "Expected 4D tensor [B, C, H, W]");

    // Read data as f32 vec
    let data: Vec<f32> = reader.into_vec().expect("Failed to read array");

    // Convert to Array4
    Array4::from_shape_vec(
        (
            shape[0] as usize,
            shape[1] as usize,
            shape[2] as usize,
            shape[3] as usize,
        ),
        data,
    )
    .expect("Shape conversion failed")
}

/// Load preprocessor config from JSON
fn load_config(path: &Path) -> PreProcessorConfig {
    let mut file = File::open(path).expect("Failed to open config");
    let mut contents = String::new();
    file.read_to_string(&mut contents).expect("Failed to read config");
    PreProcessorConfig::from_json(&contents).expect("Failed to parse config")
}

/// Compare two tensors and return max absolute difference
fn max_diff(a: &Array4<f32>, b: &Array4<f32>) -> f32 {
    assert_eq!(a.shape(), b.shape(), "Shape mismatch");
    (a - b).mapv(|v| v.abs()).fold(0.0f32, |acc, &v| acc.max(v))
}

// ============================================================================
// Standard CLIP mode tests (llava-hf/* models, no expand-to-square)
// ============================================================================

/// Test LLaVA processor (standard CLIP) against golden outputs
#[test]
fn test_llava_golden_square() {
    let golden_dir = Path::new("tests/fixtures/golden/llava");
    let image_path = Path::new("tests/fixtures/images/square.jpg");

    if !golden_dir.exists() || !image_path.exists() {
        eprintln!("Golden test fixtures not found, skipping test");
        eprintln!("Run: python scripts/generate_vision_golden.py");
        return;
    }

    // Load golden output
    let golden = load_golden_npz(&golden_dir.join("golden_square.npz"));
    let config = load_config(&golden_dir.join("preprocessor_config.json"));

    // Load and process image with Rust (default = Square mode, standard CLIP)
    let image = image::open(image_path).expect("Failed to open image");
    let processor = LlavaProcessor::new();
    let result = processor
        .preprocess(&[image], &config)
        .expect("Processing failed");

    // Compare
    let diff = max_diff(&golden, &result.pixel_values);
    println!("Golden shape: {:?}", golden.shape());
    println!("Rust shape: {:?}", result.pixel_values.shape());
    println!("Max difference: {:.6}", diff);
    println!(
        "Rust range: [{:.4}, {:.4}]",
        result
            .pixel_values
            .iter()
            .cloned()
            .fold(f32::INFINITY, f32::min),
        result
            .pixel_values
            .iter()
            .cloned()
            .fold(f32::NEG_INFINITY, f32::max)
    );
    println!(
        "Golden range: [{:.4}, {:.4}]",
        golden.iter().cloned().fold(f32::INFINITY, f32::min),
        golden.iter().cloned().fold(f32::NEG_INFINITY, f32::max)
    );

    // Allow tolerance for floating point and interpolation algorithm differences
    assert!(
        diff < 0.02,
        "Max difference {} exceeds tolerance 0.02",
        diff
    );
}

#[test]
fn test_llava_golden_tall() {
    let golden_dir = Path::new("tests/fixtures/golden/llava");
    let image_path = Path::new("tests/fixtures/images/tall.jpg");

    if !golden_dir.exists() || !image_path.exists() {
        eprintln!("Golden test fixtures not found, skipping test");
        return;
    }

    let golden = load_golden_npz(&golden_dir.join("golden_tall.npz"));
    let config = load_config(&golden_dir.join("preprocessor_config.json"));

    let image = image::open(image_path).expect("Failed to open image");
    let processor = LlavaProcessor::new();
    let result = processor
        .preprocess(&[image], &config)
        .expect("Processing failed");

    let diff = max_diff(&golden, &result.pixel_values);
    println!("Tall image - Max difference: {:.6}", diff);

    assert!(
        diff < 0.02,
        "Max difference {} exceeds tolerance 0.02",
        diff
    );
}

#[test]
fn test_llava_golden_wide() {
    let golden_dir = Path::new("tests/fixtures/golden/llava");
    let image_path = Path::new("tests/fixtures/images/wide.jpg");

    if !golden_dir.exists() || !image_path.exists() {
        eprintln!("Golden test fixtures not found, skipping test");
        return;
    }

    let golden = load_golden_npz(&golden_dir.join("golden_wide.npz"));
    let config = load_config(&golden_dir.join("preprocessor_config.json"));

    let image = image::open(image_path).expect("Failed to open image");
    let processor = LlavaProcessor::new();
    let result = processor
        .preprocess(&[image], &config)
        .expect("Processing failed");

    let diff = max_diff(&golden, &result.pixel_values);
    println!("Wide image - Max difference: {:.6}", diff);

    assert!(
        diff < 0.02,
        "Max difference {} exceeds tolerance 0.02",
        diff
    );
}

#[test]
fn test_llava_golden_small() {
    let golden_dir = Path::new("tests/fixtures/golden/llava");
    let image_path = Path::new("tests/fixtures/images/small.jpg");

    if !golden_dir.exists() || !image_path.exists() {
        eprintln!("Golden test fixtures not found, skipping test");
        return;
    }

    let golden = load_golden_npz(&golden_dir.join("golden_small.npz"));
    let config = load_config(&golden_dir.join("preprocessor_config.json"));

    let image = image::open(image_path).expect("Failed to open image");
    let processor = LlavaProcessor::new();
    let result = processor
        .preprocess(&[image], &config)
        .expect("Processing failed");

    let diff = max_diff(&golden, &result.pixel_values);
    println!("Small image - Max difference: {:.6}", diff);

    assert!(
        diff < 0.02,
        "Max difference {} exceeds tolerance 0.02",
        diff
    );
}

// ============================================================================
// Pad mode tests (liuhaotian/llava-* models, image_aspect_ratio=pad)
// ============================================================================

#[test]
fn test_llava_pad_golden_square() {
    let golden_dir = Path::new("tests/fixtures/golden/llava_pad");
    let image_path = Path::new("tests/fixtures/images/square.jpg");

    if !golden_dir.exists() || !image_path.exists() {
        eprintln!("Golden test fixtures not found, skipping test");
        return;
    }

    let golden = load_golden_npz(&golden_dir.join("golden_square.npz"));
    let config = load_config(&golden_dir.join("preprocessor_config.json"));

    let image = image::open(image_path).expect("Failed to open image");
    // Use pad mode processor
    let processor = LlavaProcessor::new_with_pad();
    let result = processor
        .preprocess(&[image], &config)
        .expect("Processing failed");

    let diff = max_diff(&golden, &result.pixel_values);
    println!("Pad mode - Square image - Max difference: {:.6}", diff);

    assert!(
        diff < 0.02,
        "Max difference {} exceeds tolerance 0.02",
        diff
    );
}

#[test]
fn test_llava_pad_golden_tall() {
    let golden_dir = Path::new("tests/fixtures/golden/llava_pad");
    let image_path = Path::new("tests/fixtures/images/tall.jpg");

    if !golden_dir.exists() || !image_path.exists() {
        eprintln!("Golden test fixtures not found, skipping test");
        return;
    }

    let golden = load_golden_npz(&golden_dir.join("golden_tall.npz"));
    let config = load_config(&golden_dir.join("preprocessor_config.json"));

    let image = image::open(image_path).expect("Failed to open image");
    let processor = LlavaProcessor::new_with_pad();
    let result = processor
        .preprocess(&[image], &config)
        .expect("Processing failed");

    let diff = max_diff(&golden, &result.pixel_values);
    println!("Pad mode - Tall image - Max difference: {:.6}", diff);

    assert!(
        diff < 0.02,
        "Max difference {} exceeds tolerance 0.02",
        diff
    );
}

#[test]
fn test_llava_pad_golden_wide() {
    let golden_dir = Path::new("tests/fixtures/golden/llava_pad");
    let image_path = Path::new("tests/fixtures/images/wide.jpg");

    if !golden_dir.exists() || !image_path.exists() {
        eprintln!("Golden test fixtures not found, skipping test");
        return;
    }

    let golden = load_golden_npz(&golden_dir.join("golden_wide.npz"));
    let config = load_config(&golden_dir.join("preprocessor_config.json"));

    let image = image::open(image_path).expect("Failed to open image");
    let processor = LlavaProcessor::new_with_pad();
    let result = processor
        .preprocess(&[image], &config)
        .expect("Processing failed");

    let diff = max_diff(&golden, &result.pixel_values);
    println!("Pad mode - Wide image - Max difference: {:.6}", diff);

    assert!(
        diff < 0.02,
        "Max difference {} exceeds tolerance 0.02",
        diff
    );
}

#[test]
fn test_llava_pad_golden_small() {
    let golden_dir = Path::new("tests/fixtures/golden/llava_pad");
    let image_path = Path::new("tests/fixtures/images/small.jpg");

    if !golden_dir.exists() || !image_path.exists() {
        eprintln!("Golden test fixtures not found, skipping test");
        return;
    }

    let golden = load_golden_npz(&golden_dir.join("golden_small.npz"));
    let config = load_config(&golden_dir.join("preprocessor_config.json"));

    let image = image::open(image_path).expect("Failed to open image");
    let processor = LlavaProcessor::new_with_pad();
    let result = processor
        .preprocess(&[image], &config)
        .expect("Processing failed");

    let diff = max_diff(&golden, &result.pixel_values);
    println!("Pad mode - Small image - Max difference: {:.6}", diff);

    assert!(
        diff < 0.02,
        "Max difference {} exceeds tolerance 0.02",
        diff
    );
}

// ============================================================================
// Token count tests
// ============================================================================

#[test]
fn test_llava_token_count() {
    let golden_dir = Path::new("tests/fixtures/golden/llava");

    if !golden_dir.exists() {
        eprintln!("Golden test fixtures not found, skipping test");
        return;
    }

    let config = load_config(&golden_dir.join("preprocessor_config.json"));
    let processor = LlavaProcessor::new();

    // LLaVA 1.5 with 336x336 and patch_size=14: (336/14)^2 = 576 tokens
    let tokens = processor.calculate_num_tokens(336, 336, &config);
    assert_eq!(
        tokens, 576,
        "Expected 576 tokens for 336x336 with patch_size=14"
    );
}
