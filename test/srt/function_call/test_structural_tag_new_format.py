"""
Unit tests for structural tag format generation.

Tests that structural tags are correctly generated by each detector,
including schema inclusion, parameter handling, and format structure.
"""

import unittest
from typing import Dict

from sglang.srt.entrypoints.openai.protocol import Tool
from sglang.srt.function_call.deepseekv3_detector import DeepSeekV3Detector
from sglang.srt.function_call.deepseekv31_detector import DeepSeekV31Detector
from sglang.srt.function_call.gpt_oss_detector import GptOssDetector
from sglang.srt.function_call.kimik2_detector import KimiK2Detector
from sglang.srt.function_call.llama32_detector import Llama32Detector
from sglang.srt.function_call.mistral_detector import MistralDetector
from sglang.srt.function_call.qwen3_coder_detector import Qwen3CoderDetector
from sglang.srt.function_call.qwen25_detector import Qwen25Detector


class StructuralTagFormatTestCase(unittest.TestCase):
    """Base test case for structural tag format tests."""

    def get_simple_tool(self) -> Tool:
        """Get a simple tool with basic parameters."""
        return Tool(
            type="function",
            function={
                "name": "get_weather",
                "description": "Get weather information",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "city": {"type": "string", "description": "City name"},
                        "unit": {
                            "type": "string",
                            "enum": ["celsius", "fahrenheit"],
                        },
                    },
                    "required": ["city"],
                },
            },
        )

    def get_empty_params_tool(self) -> Tool:
        """Get a tool with no parameters."""
        return Tool(
            type="function",
            function={
                "name": "get_time",
                "description": "Get current time",
                "parameters": None,
            },
        )

    def get_complex_tool(self) -> Tool:
        """Get a tool with complex nested parameters."""
        return Tool(
            type="function",
            function={
                "name": "analyze_data",
                "description": "Analyze complex data",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "data": {
                            "type": "object",
                            "properties": {
                                "metrics": {
                                    "type": "array",
                                    "items": {"type": "string"},
                                },
                                "config": {
                                    "type": "object",
                                    "properties": {
                                        "threshold": {"type": "number"},
                                        "enabled": {"type": "boolean"},
                                    },
                                },
                            },
                            "required": ["metrics"],
                        },
                    },
                    "required": ["data"],
                },
            },
        )

    def assert_structural_tag_structure(self, tag: Dict, expected_tools_count: int):
        """Assert that structural tag has correct structure."""
        self.assertIn("format", tag)
        self.assertIn("type", tag["format"])
        self.assertEqual(tag["format"]["type"], "triggered_tags")
        self.assertIn("triggers", tag["format"])
        self.assertIn("tags", tag["format"])
        self.assertIsInstance(tag["format"]["tags"], list)
        self.assertEqual(len(tag["format"]["tags"]), expected_tools_count)

    def assert_schema_always_included(self, tag: Dict):
        """Assert that json_schema is always included in tag content."""
        for tag_item in tag["format"]["tags"]:
            self.assertIn("content", tag_item)
            self.assertIn("type", tag_item["content"])
            content_type = tag_item["content"]["type"]

            # Handle different content types:
            # - Most detectors use "json_schema"
            # - DeepSeekV3 uses nested "tags_with_separator" (check inner tags)
            # - Qwen3Coder uses "qwen_xml_parameter"
            if content_type == "tags_with_separator":
                # DeepSeekV3 nested structure - check inner tags
                self.assertIn("tags", tag_item["content"])
                for inner_tag in tag_item["content"]["tags"]:
                    self.assertIn("content", inner_tag)
                    self.assertIn("type", inner_tag["content"])
                    self.assertEqual(inner_tag["content"]["type"], "json_schema")
                    self.assertIn("json_schema", inner_tag["content"])
            elif content_type == "qwen_xml_parameter":
                # Qwen3Coder uses qwen_xml_parameter but still has json_schema
                self.assertIn("json_schema", tag_item["content"])
            else:
                # Standard json_schema format
                self.assertEqual(content_type, "json_schema")
                self.assertIn("json_schema", tag_item["content"])

    def assert_no_format_tag_key(self, tag: Dict):
        """Assert that individual tag items do NOT have the 'format': 'tag' key.

        The 'format': 'tag' key within individual tag items was removed for
        xgrammar compatibility with stop_after_first handling.
        """
        for tag_item in tag["format"]["tags"]:
            self.assertNotIn(
                "format",
                tag_item,
                "Tag item should not have 'format' key for xgrammar compatibility",
            )


class TestLlama32Detector(StructuralTagFormatTestCase):
    """Test structural tag generation for Llama32Detector."""

    def setUp(self):
        self.detector = Llama32Detector()

    def test_schema_always_included(self):
        """Test that schema is always included even with at_least_one=False."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_schema_always_included(tag)

    def test_at_least_one_parameter(self):
        """Test that at_least_one parameter affects structural tag format."""
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=True, stop_after_first=False
        )
        self.assertFalse(tag_false["format"]["at_least_one"])
        self.assertTrue(tag_true["format"]["at_least_one"])

    def test_stop_after_first_parameter(self):
        """Test that stop_after_first parameter affects structural tag format."""
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=True
        )
        self.assertFalse(tag_false["format"]["stop_after_first"])
        self.assertTrue(tag_true["format"]["stop_after_first"])

    def test_multiple_tools(self):
        """Test that multiple tools generate multiple tags."""
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )
        self.assert_structural_tag_structure(tag, expected_tools_count=2)
        self.assert_schema_always_included(tag)

    def test_empty_parameters_handling(self):
        """Test handling of tools with no parameters."""
        tool = self.get_empty_params_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_structural_tag_structure(tag, expected_tools_count=1)
        self.assert_schema_always_included(tag)
        # Empty parameters should result in empty dict schema
        schema = tag["format"]["tags"][0]["content"]["json_schema"]
        self.assertEqual(schema, {})

    def test_structural_tag_matches_realistic_output(self):
        """Test that structural tag begin/end patterns match realistic model output."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Create realistic output: <|python_tag|>{"name":"get_weather", "arguments":{"city":"Dallas"}}
        realistic_output = (
            '<|python_tag|>{"name":"get_weather", "arguments":{"city":"Dallas"}}'
        )

        # Verify the structural tag's begin pattern matches the output
        tag_item = tag["format"]["tags"][0]
        begin = tag_item["begin"]
        end = tag_item["end"]

        # The begin should be a prefix of the realistic output
        self.assertTrue(
            realistic_output.startswith(begin),
            f"Realistic output should start with begin pattern. Begin: {begin}, Output: {realistic_output}",
        )
        # The end should be a suffix after the JSON arguments
        self.assertTrue(
            realistic_output.endswith(end),
            f"Realistic output should end with end pattern. End: {end}, Output: {realistic_output}",
        )

        # Verify tool name appears in the begin pattern
        self.assertIn(
            tool.function.name,
            begin,
            f"Tool name '{tool.function.name}' should appear in begin pattern: {begin}",
        )

        # Verify trigger appears in the realistic output
        triggers = tag["format"]["triggers"]
        self.assertTrue(
            any(trigger in realistic_output for trigger in triggers),
            f"At least one trigger should appear in realistic output. Triggers: {triggers}, Output: {realistic_output}",
        )

        # Verify that begin + JSON arguments + end forms a complete output
        # Extract the JSON part from the realistic output
        json_start = len(begin)
        json_end = len(realistic_output) - len(end)
        json_part = realistic_output[json_start:json_end]

        # Verify JSON can be inserted between begin and end
        reconstructed = begin + json_part + end
        self.assertEqual(
            reconstructed,
            realistic_output,
            f"Begin + JSON + End should reconstruct the realistic output. "
            f"Begin: {begin}, JSON: {json_part}, End: {end}",
        )

    def test_multiple_tools_generate_correct_tags(self):
        """Test that multiple tools generate separate tags with correct tool names."""
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )

        # Verify we have tags for all tools
        tags_list = tag["format"]["tags"]
        self.assertGreaterEqual(
            len(tags_list),
            len(tools),
            f"Should have at least {len(tools)} tags for {len(tools)} tools",
        )

        # Verify each tool name appears in at least one tag's begin pattern
        tool_names = {tool.function.name for tool in tools}
        tag_begins = [tag_item["begin"] for tag_item in tags_list]

        for tool_name in tool_names:
            found = any(tool_name in begin for begin in tag_begins)
            self.assertTrue(
                found,
                f"Tool name '{tool_name}' should appear in at least one tag's begin pattern. "
                f"Tag begins: {tag_begins}",
            )

    def test_no_format_tag_key(self):
        """Test that tag items do not have 'format': 'tag' key for xgrammar compatibility."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_no_format_tag_key(tag)


class TestMistralDetector(StructuralTagFormatTestCase):
    """Test structural tag generation for MistralDetector."""

    def setUp(self):
        self.detector = MistralDetector()

    def test_schema_always_included(self):
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_schema_always_included(tag)

    def test_at_least_one_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=True, stop_after_first=False
        )
        self.assertFalse(tag_false["format"]["at_least_one"])
        self.assertTrue(tag_true["format"]["at_least_one"])

    def test_stop_after_first_parameter(self):
        """Test that stop_after_first parameter affects nested content structure."""
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=True
        )
        # Mistral uses nested tags_with_separator - stop_after_first is in nested content
        # Format level stop_after_first is always True (outer wrapper only appears once)
        self.assertTrue(tag_false["format"]["stop_after_first"])
        self.assertTrue(tag_true["format"]["stop_after_first"])
        # Check nested content's stop_after_first
        self.assertFalse(tag_false["format"]["tags"][0]["content"]["stop_after_first"])
        self.assertTrue(tag_true["format"]["tags"][0]["content"]["stop_after_first"])

    def test_multiple_tools(self):
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )
        # Mistral uses nested tags_with_separator - 1 outer tag with inner tags for each tool
        self.assertEqual(len(tag["format"]["tags"]), 1)
        # Inner tags should have one entry per tool
        inner_tags = tag["format"]["tags"][0]["content"]["tags"]
        self.assertEqual(len(inner_tags), 2)

    def test_empty_parameters_handling(self):
        tool = self.get_empty_params_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        # Mistral uses nested tags_with_separator - 1 outer tag with 1 inner tag
        self.assertEqual(len(tag["format"]["tags"]), 1)
        # Schema is in the inner tag's content
        inner_tag = tag["format"]["tags"][0]["content"]["tags"][0]
        schema = inner_tag["content"]["json_schema"]
        self.assertEqual(schema, {})

    def test_structural_tag_matches_realistic_output(self):
        """Test that structural tag begin/end patterns match realistic model output."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Create realistic output for single tool call
        realistic_single = (
            '[TOOL_CALLS] [{"name":"get_weather", "arguments":{"city":"Dallas"}}]'
        )

        # Mistral uses nested tags_with_separator structure
        # Outer tag wraps the entire tool call array
        outer_tag = tag["format"]["tags"][0]
        outer_begin = outer_tag["begin"]
        outer_end = outer_tag["end"]

        self.assertTrue(
            realistic_single.startswith(outer_begin),
            f"Realistic output should start with outer begin pattern. Begin: {outer_begin}, Output: {realistic_single}",
        )
        self.assertTrue(
            realistic_single.endswith(outer_end),
            f"Realistic output should end with outer end pattern. End: {outer_end}, Output: {realistic_single}",
        )

        # Verify tool name appears in the inner tag's begin pattern
        inner_tags = outer_tag["content"]["tags"]
        tool_name_found = any(tool.function.name in t["begin"] for t in inner_tags)
        self.assertTrue(
            tool_name_found,
            f"Tool name '{tool.function.name}' should appear in an inner tag's begin pattern",
        )

        # Verify trigger appears in the realistic output
        triggers = tag["format"]["triggers"]
        self.assertTrue(
            any(trigger in realistic_single for trigger in triggers),
            f"At least one trigger should appear in realistic output. Triggers: {triggers}, Output: {realistic_single}",
        )

    def test_nested_tags_with_separator_structure(self):
        """Test that nested tags_with_separator is set up correctly for multiple tool calls."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Should have 1 outer tag with nested tags_with_separator content
        self.assertEqual(len(tag["format"]["tags"]), 1)

        outer_tag = tag["format"]["tags"][0]

        # Outer tag should include wrapper [TOOL_CALLS] [
        self.assertTrue(outer_tag["begin"].startswith("[TOOL_CALLS]"))
        self.assertEqual(outer_tag["end"], "]")

        # Verify nested content structure
        content = outer_tag["content"]
        self.assertEqual(content["type"], "tags_with_separator")
        self.assertEqual(content["separator"], ", ")
        self.assertIn("tags", content)
        self.assertEqual(len(content["tags"]), 1)  # One inner tag for one tool

        # Verify single trigger
        triggers = tag["format"]["triggers"]
        self.assertEqual(len(triggers), 1)
        self.assertIn("[TOOL_CALLS]", triggers)

    def test_multiple_tool_calls_structural_tag(self):
        """Test that structural tag supports multiple tool calls via nested structure."""
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )

        # Realistic output with multiple tool calls
        realistic_multi = (
            '[TOOL_CALLS] [{"name":"get_weather", "arguments":{"city":"Dallas"}}'
            ', {"name":"analyze_data", "arguments":{"data":{"metrics":["cpu","mem"]}}}'
            "]"
        )

        # Verify we have 1 outer tag with multiple inner tags
        self.assertEqual(len(tag["format"]["tags"]), 1)
        outer_tag = tag["format"]["tags"][0]

        # Verify outer tag matches start and end
        self.assertTrue(realistic_multi.startswith(outer_tag["begin"]))
        self.assertTrue(realistic_multi.endswith(outer_tag["end"]))

        # Verify inner tags exist for each tool
        inner_tags = outer_tag["content"]["tags"]
        self.assertEqual(len(inner_tags), 2)  # One per tool

        # Verify tool names appear in inner tags
        tool_names = {tool.function.name for tool in tools}
        for inner_tag in inner_tags:
            # Each inner tag's begin should contain a tool name
            found_name = any(name in inner_tag["begin"] for name in tool_names)
            self.assertTrue(
                found_name,
                f"Inner tag begin should contain a tool name: {inner_tag['begin']}",
            )

    def test_no_format_tag_key(self):
        """Test that tag items do not have 'format': 'tag' key for xgrammar compatibility."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_no_format_tag_key(tag)


class TestQwen25Detector(StructuralTagFormatTestCase):
    """Test structural tag generation for Qwen25Detector."""

    def setUp(self):
        self.detector = Qwen25Detector()

    def test_schema_always_included(self):
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_schema_always_included(tag)

    def test_at_least_one_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=True, stop_after_first=False
        )
        self.assertFalse(tag_false["format"]["at_least_one"])
        self.assertTrue(tag_true["format"]["at_least_one"])

    def test_stop_after_first_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=True
        )
        self.assertFalse(tag_false["format"]["stop_after_first"])
        self.assertTrue(tag_true["format"]["stop_after_first"])

    def test_multiple_tools(self):
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )
        self.assert_structural_tag_structure(tag, expected_tools_count=2)

    def test_empty_parameters_handling(self):
        tool = self.get_empty_params_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_structural_tag_structure(tag, expected_tools_count=1)
        schema = tag["format"]["tags"][0]["content"]["json_schema"]
        self.assertEqual(schema, {})

    def test_structural_tag_matches_realistic_output(self):
        """Test that structural tag begin/end patterns match realistic model output."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Create realistic output: <tool_call>\n{"name":"get_weather", "arguments":{"city":"Dallas"}}\n</tool_call>
        realistic_output = '<tool_call>\n{"name":"get_weather", "arguments":{"city":"Dallas"}}\n</tool_call>'

        # Verify the structural tag's begin pattern matches the output
        tag_item = tag["format"]["tags"][0]
        begin = tag_item["begin"]
        end = tag_item["end"]

        self.assertTrue(
            realistic_output.startswith(begin),
            f"Realistic output should start with begin pattern. Begin: {begin}, Output: {realistic_output}",
        )
        self.assertTrue(
            realistic_output.endswith(end),
            f"Realistic output should end with end pattern. End: {end}, Output: {realistic_output}",
        )

        # Verify tool name appears in the begin pattern
        self.assertIn(
            tool.function.name,
            begin,
            f"Tool name '{tool.function.name}' should appear in begin pattern: {begin}",
        )

        # Verify trigger appears in the realistic output
        triggers = tag["format"]["triggers"]
        self.assertTrue(
            any(trigger in realistic_output for trigger in triggers),
            f"At least one trigger should appear in realistic output. Triggers: {triggers}, Output: {realistic_output}",
        )

    def test_no_format_tag_key(self):
        """Test that tag items do not have 'format': 'tag' key for xgrammar compatibility."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_no_format_tag_key(tag)


class TestQwen3CoderDetector(StructuralTagFormatTestCase):
    """Test structural tag generation for Qwen3CoderDetector."""

    def setUp(self):
        self.detector = Qwen3CoderDetector()

    def test_schema_always_included(self):
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_schema_always_included(tag)

    def test_at_least_one_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=True, stop_after_first=False
        )
        self.assertFalse(tag_false["format"]["at_least_one"])
        self.assertTrue(tag_true["format"]["at_least_one"])

    def test_stop_after_first_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=True
        )
        self.assertFalse(tag_false["format"]["stop_after_first"])
        self.assertTrue(tag_true["format"]["stop_after_first"])

    def test_multiple_tools(self):
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )
        self.assert_structural_tag_structure(tag, expected_tools_count=2)

    def test_empty_parameters_handling(self):
        tool = self.get_empty_params_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_structural_tag_structure(tag, expected_tools_count=1)
        schema = tag["format"]["tags"][0]["content"]["json_schema"]
        self.assertEqual(schema, {})

    def test_structural_tag_matches_realistic_output(self):
        """Test that structural tag begin/end patterns match realistic model output."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Create realistic output: <tool_call>\n<function=get_weather>\n<parameter=city>\nDallas\n</parameter>\n</function>\n</tool_call>
        realistic_output = (
            "<tool_call>\n<function=get_weather>\n<parameter=city>\nDallas\n</parameter>\n"
            "<parameter=unit>\nfahrenheit\n</parameter>\n</function>\n</tool_call>"
        )

        # Verify the structural tag's begin pattern matches the output
        tag_item = tag["format"]["tags"][0]
        begin = tag_item["begin"]
        end = tag_item["end"]

        self.assertTrue(
            realistic_output.startswith(begin),
            f"Realistic output should start with begin pattern. Begin: {begin}, Output: {realistic_output}",
        )
        self.assertTrue(
            realistic_output.endswith(end),
            f"Realistic output should end with end pattern. End: {end}, Output: {realistic_output}",
        )

    def test_no_format_tag_key(self):
        """Test that tag items do not have 'format': 'tag' key for xgrammar compatibility."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_no_format_tag_key(tag)


class TestDeepSeekV3Detector(StructuralTagFormatTestCase):
    """Test structural tag generation for DeepSeekV3Detector."""

    def setUp(self):
        self.detector = DeepSeekV3Detector()

    def test_schema_always_included(self):
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_schema_always_included(tag)

    def test_at_least_one_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=True, stop_after_first=False
        )
        # DeepSeekV3 uses flat structure with dual triggers, at_least_one is at format level
        self.assertFalse(tag_false["format"]["at_least_one"])
        self.assertTrue(tag_true["format"]["at_least_one"])

    def test_stop_after_first_parameter(self):
        """Test that stop_after_first parameter affects nested content structure."""
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=True
        )
        # DeepSeekV3 uses nested tags_with_separator - stop_after_first is in nested content
        # Format level stop_after_first is always True (outer wrapper only appears once)
        self.assertTrue(tag_false["format"]["stop_after_first"])
        self.assertTrue(tag_true["format"]["stop_after_first"])
        # Check nested content's stop_after_first
        self.assertFalse(tag_false["format"]["tags"][0]["content"]["stop_after_first"])
        self.assertTrue(tag_true["format"]["tags"][0]["content"]["stop_after_first"])

    def test_multiple_tools(self):
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )
        # DeepSeekV3 uses nested tags_with_separator - 1 outer tag with inner tags for each tool
        self.assertIn("format", tag)
        self.assertEqual(len(tag["format"]["tags"]), 1)
        # Inner tags should have one entry per tool
        inner_tags = tag["format"]["tags"][0]["content"]["tags"]
        self.assertEqual(len(inner_tags), 2)

    def test_empty_parameters_handling(self):
        tool = self.get_empty_params_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assertIn("format", tag)
        # DeepSeekV3 uses nested tags_with_separator - 1 outer tag with 1 inner tag
        self.assertEqual(len(tag["format"]["tags"]), 1)
        # Schema is in the inner tag's content
        inner_tag = tag["format"]["tags"][0]["content"]["tags"][0]
        schema = inner_tag["content"]["json_schema"]
        self.assertEqual(schema, {})

    def test_structural_tag_matches_realistic_output(self):
        """Test that structural tag begin/end patterns match realistic model output."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Create realistic output for single tool call
        realistic_output = (
            "<｜tool▁calls▁begin｜><｜tool▁call▁begin｜>function<｜tool▁sep｜>get_weather\n"
            '```json\n{"city":"Dallas"}\n```<｜tool▁call▁end｜><｜tool▁calls▁end｜>'
        )

        # DeepSeekV3 uses nested tags_with_separator structure
        # Outer tag wraps the entire tool calls section
        outer_tag = tag["format"]["tags"][0]
        outer_begin = outer_tag["begin"]
        outer_end = outer_tag["end"]

        # Verify outer tag matches start
        self.assertTrue(
            realistic_output.startswith(outer_begin),
            f"Realistic output should start with outer begin pattern. Begin: {outer_begin}, Output: {realistic_output}",
        )
        # Verify outer tag matches end
        self.assertTrue(
            realistic_output.endswith(outer_end),
            f"Realistic output should end with outer end pattern. End: {outer_end}, Output: {realistic_output}",
        )

        # Verify tool name appears in inner tag's begin pattern
        inner_tags = outer_tag["content"]["tags"]
        tool_name_found = any(tool.function.name in t["begin"] for t in inner_tags)
        self.assertTrue(
            tool_name_found,
            f"Tool name '{tool.function.name}' should appear in an inner tag's begin pattern",
        )

        # Verify single trigger (outer wrapper trigger)
        triggers = tag["format"]["triggers"]
        self.assertEqual(len(triggers), 1)
        self.assertIn("<｜tool▁calls▁begin｜>", triggers)

    def test_nested_tags_with_separator_structure(self):
        """Test that nested tags_with_separator is set up correctly for multiple tool calls."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Should have 1 outer tag with nested tags_with_separator content
        self.assertEqual(len(tag["format"]["tags"]), 1)

        outer_tag = tag["format"]["tags"][0]

        # Outer tag should include wrapper
        self.assertTrue(outer_tag["begin"].startswith("<｜tool▁calls▁begin｜>"))
        self.assertEqual(outer_tag["end"], "<｜tool▁calls▁end｜>")

        # Verify nested content structure
        content = outer_tag["content"]
        self.assertEqual(content["type"], "tags_with_separator")
        self.assertIn("separator", content)
        self.assertIn("tags", content)
        self.assertEqual(len(content["tags"]), 1)  # One inner tag for one tool

        # Verify single trigger
        triggers = tag["format"]["triggers"]
        self.assertEqual(len(triggers), 1)
        self.assertIn("<｜tool▁calls▁begin｜>", triggers)

    def test_no_format_tag_key(self):
        """Test that tag items do not have 'format': 'tag' key for xgrammar compatibility."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_no_format_tag_key(tag)


class TestDeepSeekV31Detector(StructuralTagFormatTestCase):
    """Test structural tag generation for DeepSeekV31Detector."""

    def setUp(self):
        self.detector = DeepSeekV31Detector()

    def test_schema_always_included(self):
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        # DeepSeekV31 uses flat structure - check first tag's schema
        first_tag = tag["format"]["tags"][0]
        self.assertIn("content", first_tag)
        self.assertIn("json_schema", first_tag["content"])

    def test_at_least_one_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=True, stop_after_first=False
        )
        # DeepSeekV31 uses flat structure with dual triggers, at_least_one is at format level
        self.assertFalse(tag_false["format"]["at_least_one"])
        self.assertTrue(tag_true["format"]["at_least_one"])

    def test_stop_after_first_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=True
        )
        self.assertFalse(tag_false["format"]["stop_after_first"])
        self.assertTrue(tag_true["format"]["stop_after_first"])

    def test_multiple_tools(self):
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )
        # DeepSeekV31 uses dual triggers - 2 tags per tool (first call + subsequent calls)
        # 2 tools * 2 variants = 4 tags
        self.assertEqual(len(tag["format"]["tags"]), 4)

    def test_empty_parameters_handling(self):
        tool = self.get_empty_params_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        # DeepSeekV31 uses flat structure - check first tag's schema
        first_tag = tag["format"]["tags"][0]
        schema = first_tag["content"]["json_schema"]
        self.assertEqual(schema, {})

    def test_structural_tag_matches_realistic_output(self):
        """Test that structural tag begin/end patterns match realistic model output."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Create realistic output for single tool call
        realistic_output = (
            "<｜tool▁calls▁begin｜><｜tool▁call▁begin｜>get_weather<｜tool▁sep｜>"
            '{"city":"Dallas"}<｜tool▁call▁end｜><｜tool▁calls▁end｜>'
        )

        # First tag is for first tool call (includes outer wrapper)
        first_tag = tag["format"]["tags"][0]
        first_begin = first_tag["begin"]
        first_end = first_tag["end"]

        # Verify the first tag's begin pattern matches the output
        self.assertTrue(
            realistic_output.startswith(first_begin),
            f"Realistic output should start with first tag begin. Begin: {first_begin}, Output: {realistic_output}",
        )

        # Verify tool name appears in the begin pattern
        self.assertIn(
            tool.function.name,
            first_begin,
            f"Tool name '{tool.function.name}' should appear in begin pattern: {first_begin}",
        )

        # Verify both triggers appear in the triggers list
        triggers = tag["format"]["triggers"]
        self.assertEqual(len(triggers), 2)
        self.assertIn("<｜tool▁calls▁begin｜>", triggers)
        self.assertIn("<｜tool▁call▁begin｜>", triggers)

    def test_dual_trigger_structure(self):
        """Test that dual triggers are set up correctly for multiple tool calls."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Should have 2 tags: one for first call, one for subsequent calls
        self.assertEqual(len(tag["format"]["tags"]), 2)

        first_tag = tag["format"]["tags"][0]
        subsequent_tag = tag["format"]["tags"][1]

        # First tag should include outer wrapper
        self.assertTrue(first_tag["begin"].startswith("<｜tool▁calls▁begin｜>"))
        # Subsequent tag should not include outer wrapper
        self.assertFalse(subsequent_tag["begin"].startswith("<｜tool▁calls▁begin｜>"))
        self.assertTrue(subsequent_tag["begin"].startswith("<｜tool▁call▁begin｜>"))

    def test_no_format_tag_key(self):
        """Test that tag items do not have 'format': 'tag' key for xgrammar compatibility."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_no_format_tag_key(tag)


class TestGptOssDetector(StructuralTagFormatTestCase):
    """Test structural tag generation for GptOssDetector."""

    def setUp(self):
        self.detector = GptOssDetector()

    def test_schema_always_included(self):
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        # GPT-OSS has two patterns per tool (reasoning enabled/disabled)
        self.assertEqual(len(tag["format"]["tags"]), 2)
        for tag_item in tag["format"]["tags"]:
            self.assertIn("content", tag_item)
            self.assertIn("json_schema", tag_item["content"])

    def test_at_least_one_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=True, stop_after_first=False
        )
        self.assertFalse(tag_false["format"]["at_least_one"])
        self.assertTrue(tag_true["format"]["at_least_one"])

    def test_stop_after_first_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=True
        )
        self.assertFalse(tag_false["format"]["stop_after_first"])
        self.assertTrue(tag_true["format"]["stop_after_first"])

    def test_multiple_tools(self):
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )
        # GPT-OSS has 2 patterns per tool
        self.assertEqual(len(tag["format"]["tags"]), 4)

    def test_empty_parameters_handling(self):
        tool = self.get_empty_params_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assertEqual(len(tag["format"]["tags"]), 2)
        for tag_item in tag["format"]["tags"]:
            schema = tag_item["content"]["json_schema"]
            self.assertEqual(schema, {})

    def test_structural_tag_matches_realistic_output(self):
        """Test that structural tag begin/end patterns match realistic model output."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Create realistic output: <|start|>assistant<|channel|>commentary to=functions.get_weather<|constrain|>json<|message|>{"city":"Dallas"}<|call|>
        # Note: GPT-OSS detector's has_tool_call() checks for "<|start|>assistant<|channel|>commentary"
        realistic_output = '<|start|>assistant<|channel|>commentary to=functions.get_weather<|constrain|>json<|message|>{"city":"Dallas"}<|call|>'

        # GPT-OSS has two patterns per tool, check if either matches
        tag_items = tag["format"]["tags"]
        found_match = False
        for tag_item in tag_items:
            begin = tag_item["begin"]
            end = tag_item["end"]
            if realistic_output.startswith(begin):
                found_match = True
                # End is empty for GPT-OSS, so just check begin
                break

        self.assertTrue(
            found_match,
            f"Realistic output should match one of the structural tag patterns. Output: {realistic_output}",
        )

        # For GPT-OSS, verify tool name appears in at least one tag's begin pattern
        tag_items = tag["format"]["tags"]
        tool_name_found = any(
            tool.function.name in tag_item["begin"] for tag_item in tag_items
        )
        self.assertTrue(
            tool_name_found,
            f"Tool name '{tool.function.name}' should appear in at least one tag's begin pattern",
        )

        # Verify trigger appears in the realistic output
        triggers = tag["format"]["triggers"]
        self.assertTrue(
            any(trigger in realistic_output for trigger in triggers),
            f"At least one trigger should appear in realistic output. Triggers: {triggers}, Output: {realistic_output}",
        )

    def test_no_format_tag_key(self):
        """Test that tag items do not have 'format': 'tag' key for xgrammar compatibility."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_no_format_tag_key(tag)


class TestKimiK2Detector(StructuralTagFormatTestCase):
    """Test structural tag generation for KimiK2Detector."""

    def setUp(self):
        self.detector = KimiK2Detector()

    def test_schema_always_included(self):
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_schema_always_included(tag)

    def test_at_least_one_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=True, stop_after_first=False
        )
        self.assertFalse(tag_false["format"]["at_least_one"])
        self.assertTrue(tag_true["format"]["at_least_one"])

    def test_stop_after_first_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=True
        )
        self.assertFalse(tag_false["format"]["stop_after_first"])
        self.assertTrue(tag_true["format"]["stop_after_first"])

    def test_multiple_tools(self):
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )
        # KimiK2 uses dual triggers - 2 tags per tool (first call + subsequent calls)
        # 2 tools * 2 variants = 4 tags
        self.assertEqual(len(tag["format"]["tags"]), 4)

    def test_empty_parameters_handling(self):
        tool = self.get_empty_params_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        # KimiK2 uses dual triggers - 2 tags per tool (first call + subsequent calls)
        self.assertEqual(len(tag["format"]["tags"]), 2)
        for tag_item in tag["format"]["tags"]:
            schema = tag_item["content"]["json_schema"]
            self.assertEqual(schema, {})

    def test_structural_tag_matches_realistic_output(self):
        """Test that structural tag begin/end patterns match realistic model output."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Create realistic output: <|tool_calls_section_begin|><|tool_call_begin|>functions.get_weather:0<|tool_call_argument_begin|>{"city":"Dallas"}<|tool_call_end|><|tool_calls_section_end|>
        # Note: KimiK2 uses index in the format, so we need to check with index 0
        realistic_output = '<|tool_calls_section_begin|><|tool_call_begin|>functions.get_weather:0<|tool_call_argument_begin|>{"city":"Dallas"}<|tool_call_end|><|tool_calls_section_end|>'

        # Verify the structural tag's begin pattern matches the output (first tag is for first call)
        tag_item = tag["format"]["tags"][0]
        begin = tag_item["begin"]
        end = tag_item["end"]

        self.assertTrue(
            realistic_output.startswith(begin),
            f"Realistic output should start with begin pattern. Begin: {begin}, Output: {realistic_output}",
        )
        # The end pattern is <|tool_call_end|> which appears in the output
        # (but doesn't include section_end since that allows multiple tool calls)
        self.assertIn(
            end,
            realistic_output,
            f"End pattern should appear in realistic output. End: {end}, Output: {realistic_output}",
        )

        # Verify tool name appears in the begin pattern (may include index for KimiK2)
        # KimiK2 format includes index like "functions.get_weather:0"
        tool_name_base = tool.function.name
        self.assertTrue(
            tool_name_base in begin or f"functions.{tool_name_base}" in begin,
            f"Tool name '{tool_name_base}' should appear in begin pattern: {begin}",
        )

        # Verify both triggers appear in format
        triggers = tag["format"]["triggers"]
        self.assertEqual(len(triggers), 2)
        self.assertIn("<|tool_calls_section_begin|>", triggers)
        self.assertIn("<|tool_call_begin|>", triggers)

        # Verify triggers appear in the realistic output
        self.assertTrue(
            any(trigger in realistic_output for trigger in triggers),
            f"At least one trigger should appear in realistic output. Triggers: {triggers}, Output: {realistic_output}",
        )

    def test_multiple_tool_calls_structural_tag(self):
        """Test that structural tag supports multiple tool calls in sequence."""
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )

        # Realistic output with multiple tool calls
        realistic_output = (
            "<|tool_calls_section_begin|>"
            '<|tool_call_begin|>functions.get_weather:0<|tool_call_argument_begin|>{"city":"Paris"}<|tool_call_end|>'
            '<|tool_call_begin|>functions.search:1<|tool_call_argument_begin|>{"query":"hotels","limit":10}<|tool_call_end|>'
            "<|tool_calls_section_end|>"
        )

        # Verify we have tags for first call (with section_begin) and subsequent calls (without)
        tags = tag["format"]["tags"]
        first_call_tags = [
            t for t in tags if "<|tool_calls_section_begin|>" in t["begin"]
        ]
        subsequent_call_tags = [
            t for t in tags if "<|tool_calls_section_begin|>" not in t["begin"]
        ]

        self.assertEqual(len(first_call_tags), 2)  # One per tool
        self.assertEqual(len(subsequent_call_tags), 2)  # One per tool

        # Verify that subsequent call tags use just <|tool_call_begin|>
        for t in subsequent_call_tags:
            self.assertTrue(t["begin"].startswith("<|tool_call_begin|>"))
            self.assertNotIn("<|tool_calls_section_begin|>", t["begin"])

    def test_no_format_tag_key(self):
        """Test that tag items do not have 'format': 'tag' key for xgrammar compatibility."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_no_format_tag_key(tag)


# Note: Glm4MoeDetector, PythonicDetector, Step3Detector, and MinimaxM2Detector
# return False for supports_structural_tag() and raise NotImplementedError
# for build_structural_tag(), so they are not tested here.


if __name__ == "__main__":
    unittest.main()
