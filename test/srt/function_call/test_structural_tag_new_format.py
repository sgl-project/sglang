"""
Unit tests for structural tag format generation.

Tests that structural tags are correctly generated by each detector,
including schema inclusion, parameter handling, and format structure.
"""

import unittest
from typing import Dict

from sglang.srt.entrypoints.openai.protocol import Tool
from sglang.srt.function_call.deepseekv3_detector import DeepSeekV3Detector
from sglang.srt.function_call.deepseekv31_detector import DeepSeekV31Detector
from sglang.srt.function_call.gpt_oss_detector import GptOssDetector
from sglang.srt.function_call.kimik2_detector import KimiK2Detector
from sglang.srt.function_call.llama32_detector import Llama32Detector
from sglang.srt.function_call.mistral_detector import MistralDetector
from sglang.srt.function_call.qwen3_coder_detector import Qwen3CoderDetector
from sglang.srt.function_call.qwen25_detector import Qwen25Detector


class StructuralTagFormatTestCase(unittest.TestCase):
    """Base test case for structural tag format tests."""

    def get_simple_tool(self) -> Tool:
        """Get a simple tool with basic parameters."""
        return Tool(
            type="function",
            function={
                "name": "get_weather",
                "description": "Get weather information",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "city": {"type": "string", "description": "City name"},
                        "unit": {
                            "type": "string",
                            "enum": ["celsius", "fahrenheit"],
                        },
                    },
                    "required": ["city"],
                },
            },
        )

    def get_empty_params_tool(self) -> Tool:
        """Get a tool with no parameters."""
        return Tool(
            type="function",
            function={
                "name": "get_time",
                "description": "Get current time",
                "parameters": None,
            },
        )

    def get_complex_tool(self) -> Tool:
        """Get a tool with complex nested parameters."""
        return Tool(
            type="function",
            function={
                "name": "analyze_data",
                "description": "Analyze complex data",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "data": {
                            "type": "object",
                            "properties": {
                                "metrics": {
                                    "type": "array",
                                    "items": {"type": "string"},
                                },
                                "config": {
                                    "type": "object",
                                    "properties": {
                                        "threshold": {"type": "number"},
                                        "enabled": {"type": "boolean"},
                                    },
                                },
                            },
                            "required": ["metrics"],
                        },
                    },
                    "required": ["data"],
                },
            },
        )

    def assert_structural_tag_structure(self, tag: Dict, expected_tools_count: int):
        """Assert that structural tag has correct structure."""
        self.assertIn("format", tag)
        self.assertIn("type", tag["format"])
        self.assertEqual(tag["format"]["type"], "triggered_tags")
        self.assertIn("triggers", tag["format"])
        self.assertIn("tags", tag["format"])
        self.assertIsInstance(tag["format"]["tags"], list)
        self.assertEqual(len(tag["format"]["tags"]), expected_tools_count)

    def assert_schema_always_included(self, tag: Dict):
        """Assert that json_schema is always included in tag content."""
        for tag_item in tag["format"]["tags"]:
            self.assertIn("content", tag_item)
            self.assertIn("type", tag_item["content"])
            content_type = tag_item["content"]["type"]

            # Handle different content types:
            # - Most detectors use "json_schema"
            # - DeepSeekV3 uses nested "tags_with_separator" (check inner tags)
            # - Qwen3Coder uses "qwen_xml_parameter"
            if content_type == "tags_with_separator":
                # DeepSeekV3 nested structure - check inner tags
                self.assertIn("tags", tag_item["content"])
                for inner_tag in tag_item["content"]["tags"]:
                    self.assertIn("content", inner_tag)
                    self.assertIn("type", inner_tag["content"])
                    self.assertEqual(inner_tag["content"]["type"], "json_schema")
                    self.assertIn("json_schema", inner_tag["content"])
            elif content_type == "qwen_xml_parameter":
                # Qwen3Coder uses qwen_xml_parameter but still has json_schema
                self.assertIn("json_schema", tag_item["content"])
            else:
                # Standard json_schema format
                self.assertEqual(content_type, "json_schema")
                self.assertIn("json_schema", tag_item["content"])


class TestLlama32Detector(StructuralTagFormatTestCase):
    """Test structural tag generation for Llama32Detector."""

    def setUp(self):
        self.detector = Llama32Detector()

    def test_schema_always_included(self):
        """Test that schema is always included even with at_least_one=False."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_schema_always_included(tag)

    def test_at_least_one_parameter(self):
        """Test that at_least_one parameter affects structural tag format."""
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=True, stop_after_first=False
        )
        self.assertFalse(tag_false["format"]["at_least_one"])
        self.assertTrue(tag_true["format"]["at_least_one"])

    def test_stop_after_first_parameter(self):
        """Test that stop_after_first parameter affects structural tag format."""
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=True
        )
        self.assertFalse(tag_false["format"]["stop_after_first"])
        self.assertTrue(tag_true["format"]["stop_after_first"])

    def test_multiple_tools(self):
        """Test that multiple tools generate multiple tags."""
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )
        self.assert_structural_tag_structure(tag, expected_tools_count=2)
        self.assert_schema_always_included(tag)

    def test_empty_parameters_handling(self):
        """Test handling of tools with no parameters."""
        tool = self.get_empty_params_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_structural_tag_structure(tag, expected_tools_count=1)
        self.assert_schema_always_included(tag)
        # Empty parameters should result in empty dict schema
        schema = tag["format"]["tags"][0]["content"]["json_schema"]
        self.assertEqual(schema, {})

    def test_structural_tag_matches_realistic_output(self):
        """Test that structural tag begin/end patterns match realistic model output."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Create realistic output: <|python_tag|>{"name":"get_weather", "arguments":{"city":"Dallas"}}
        realistic_output = (
            '<|python_tag|>{"name":"get_weather", "arguments":{"city":"Dallas"}}'
        )

        # Verify the structural tag's begin pattern matches the output
        tag_item = tag["format"]["tags"][0]
        begin = tag_item["begin"]
        end = tag_item["end"]

        # The begin should be a prefix of the realistic output
        self.assertTrue(
            realistic_output.startswith(begin),
            f"Realistic output should start with begin pattern. Begin: {begin}, Output: {realistic_output}",
        )
        # The end should be a suffix after the JSON arguments
        self.assertTrue(
            realistic_output.endswith(end),
            f"Realistic output should end with end pattern. End: {end}, Output: {realistic_output}",
        )

        # Verify tool name appears in the begin pattern
        self.assertIn(
            tool.function.name,
            begin,
            f"Tool name '{tool.function.name}' should appear in begin pattern: {begin}",
        )

        # Verify trigger appears in the realistic output
        triggers = tag["format"]["triggers"]
        self.assertTrue(
            any(trigger in realistic_output for trigger in triggers),
            f"At least one trigger should appear in realistic output. Triggers: {triggers}, Output: {realistic_output}",
        )

        # Verify that begin + JSON arguments + end forms a complete output
        # Extract the JSON part from the realistic output
        json_start = len(begin)
        json_end = len(realistic_output) - len(end)
        json_part = realistic_output[json_start:json_end]

        # Verify JSON can be inserted between begin and end
        reconstructed = begin + json_part + end
        self.assertEqual(
            reconstructed,
            realistic_output,
            f"Begin + JSON + End should reconstruct the realistic output. "
            f"Begin: {begin}, JSON: {json_part}, End: {end}",
        )

    def test_multiple_tools_generate_correct_tags(self):
        """Test that multiple tools generate separate tags with correct tool names."""
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )

        # Verify we have tags for all tools
        tags_list = tag["format"]["tags"]
        self.assertGreaterEqual(
            len(tags_list),
            len(tools),
            f"Should have at least {len(tools)} tags for {len(tools)} tools",
        )

        # Verify each tool name appears in at least one tag's begin pattern
        tool_names = {tool.function.name for tool in tools}
        tag_begins = [tag_item["begin"] for tag_item in tags_list]

        for tool_name in tool_names:
            found = any(tool_name in begin for begin in tag_begins)
            self.assertTrue(
                found,
                f"Tool name '{tool_name}' should appear in at least one tag's begin pattern. "
                f"Tag begins: {tag_begins}",
            )


class TestMistralDetector(StructuralTagFormatTestCase):
    """Test structural tag generation for MistralDetector."""

    def setUp(self):
        self.detector = MistralDetector()

    def test_schema_always_included(self):
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_schema_always_included(tag)

    def test_at_least_one_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=True, stop_after_first=False
        )
        self.assertFalse(tag_false["format"]["at_least_one"])
        self.assertTrue(tag_true["format"]["at_least_one"])

    def test_stop_after_first_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=True
        )
        self.assertFalse(tag_false["format"]["stop_after_first"])
        self.assertTrue(tag_true["format"]["stop_after_first"])

    def test_multiple_tools(self):
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )
        self.assert_structural_tag_structure(tag, expected_tools_count=2)

    def test_empty_parameters_handling(self):
        tool = self.get_empty_params_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_structural_tag_structure(tag, expected_tools_count=1)
        schema = tag["format"]["tags"][0]["content"]["json_schema"]
        self.assertEqual(schema, {})

    def test_structural_tag_matches_realistic_output(self):
        """Test that structural tag begin/end patterns match realistic model output."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Create realistic output: [TOOL_CALLS] [{"name":"get_weather", "arguments":{"city":"Dallas"}}]
        realistic_output = (
            '[TOOL_CALLS] [{"name":"get_weather", "arguments":{"city":"Dallas"}}]'
        )

        # Verify the structural tag's begin pattern matches the output
        tag_item = tag["format"]["tags"][0]
        begin = tag_item["begin"]
        end = tag_item["end"]

        self.assertTrue(
            realistic_output.startswith(begin),
            f"Realistic output should start with begin pattern. Begin: {begin}, Output: {realistic_output}",
        )
        self.assertTrue(
            realistic_output.endswith(end),
            f"Realistic output should end with end pattern. End: {end}, Output: {realistic_output}",
        )

        # Verify tool name appears in the begin pattern
        self.assertIn(
            tool.function.name,
            begin,
            f"Tool name '{tool.function.name}' should appear in begin pattern: {begin}",
        )

        # Verify trigger appears in the realistic output
        triggers = tag["format"]["triggers"]
        self.assertTrue(
            any(trigger in realistic_output for trigger in triggers),
            f"At least one trigger should appear in realistic output. Triggers: {triggers}, Output: {realistic_output}",
        )

        # Verify that begin + JSON arguments + end forms a complete output
        json_start = len(begin)
        json_end = len(realistic_output) - len(end)
        json_part = realistic_output[json_start:json_end]
        reconstructed = begin + json_part + end
        self.assertEqual(
            reconstructed,
            realistic_output,
            f"Begin + JSON + End should reconstruct the realistic output",
        )


class TestQwen25Detector(StructuralTagFormatTestCase):
    """Test structural tag generation for Qwen25Detector."""

    def setUp(self):
        self.detector = Qwen25Detector()

    def test_schema_always_included(self):
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_schema_always_included(tag)

    def test_at_least_one_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=True, stop_after_first=False
        )
        self.assertFalse(tag_false["format"]["at_least_one"])
        self.assertTrue(tag_true["format"]["at_least_one"])

    def test_stop_after_first_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=True
        )
        self.assertFalse(tag_false["format"]["stop_after_first"])
        self.assertTrue(tag_true["format"]["stop_after_first"])

    def test_multiple_tools(self):
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )
        self.assert_structural_tag_structure(tag, expected_tools_count=2)

    def test_empty_parameters_handling(self):
        tool = self.get_empty_params_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_structural_tag_structure(tag, expected_tools_count=1)
        schema = tag["format"]["tags"][0]["content"]["json_schema"]
        self.assertEqual(schema, {})

    def test_structural_tag_matches_realistic_output(self):
        """Test that structural tag begin/end patterns match realistic model output."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Create realistic output: <tool_call>\n{"name":"get_weather", "arguments":{"city":"Dallas"}}\n</tool_call>
        realistic_output = '<tool_call>\n{"name":"get_weather", "arguments":{"city":"Dallas"}}\n</tool_call>'

        # Verify the structural tag's begin pattern matches the output
        tag_item = tag["format"]["tags"][0]
        begin = tag_item["begin"]
        end = tag_item["end"]

        self.assertTrue(
            realistic_output.startswith(begin),
            f"Realistic output should start with begin pattern. Begin: {begin}, Output: {realistic_output}",
        )
        self.assertTrue(
            realistic_output.endswith(end),
            f"Realistic output should end with end pattern. End: {end}, Output: {realistic_output}",
        )

        # Verify tool name appears in the begin pattern
        self.assertIn(
            tool.function.name,
            begin,
            f"Tool name '{tool.function.name}' should appear in begin pattern: {begin}",
        )

        # Verify trigger appears in the realistic output
        triggers = tag["format"]["triggers"]
        self.assertTrue(
            any(trigger in realistic_output for trigger in triggers),
            f"At least one trigger should appear in realistic output. Triggers: {triggers}, Output: {realistic_output}",
        )


class TestQwen3CoderDetector(StructuralTagFormatTestCase):
    """Test structural tag generation for Qwen3CoderDetector."""

    def setUp(self):
        self.detector = Qwen3CoderDetector()

    def test_schema_always_included(self):
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_schema_always_included(tag)

    def test_at_least_one_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=True, stop_after_first=False
        )
        self.assertFalse(tag_false["format"]["at_least_one"])
        self.assertTrue(tag_true["format"]["at_least_one"])

    def test_stop_after_first_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=True
        )
        self.assertFalse(tag_false["format"]["stop_after_first"])
        self.assertTrue(tag_true["format"]["stop_after_first"])

    def test_multiple_tools(self):
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )
        self.assert_structural_tag_structure(tag, expected_tools_count=2)

    def test_empty_parameters_handling(self):
        tool = self.get_empty_params_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_structural_tag_structure(tag, expected_tools_count=1)
        schema = tag["format"]["tags"][0]["content"]["json_schema"]
        self.assertEqual(schema, {})

    def test_structural_tag_matches_realistic_output(self):
        """Test that structural tag begin/end patterns match realistic model output."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Create realistic output: <tool_call>\n<function=get_weather>\n<parameter=city>\nDallas\n</parameter>\n</function>\n</tool_call>
        realistic_output = (
            "<tool_call>\n<function=get_weather>\n<parameter=city>\nDallas\n</parameter>\n"
            "<parameter=unit>\nfahrenheit\n</parameter>\n</function>\n</tool_call>"
        )

        # Verify the structural tag's begin pattern matches the output
        tag_item = tag["format"]["tags"][0]
        begin = tag_item["begin"]
        end = tag_item["end"]

        self.assertTrue(
            realistic_output.startswith(begin),
            f"Realistic output should start with begin pattern. Begin: {begin}, Output: {realistic_output}",
        )
        self.assertTrue(
            realistic_output.endswith(end),
            f"Realistic output should end with end pattern. End: {end}, Output: {realistic_output}",
        )


class TestDeepSeekV3Detector(StructuralTagFormatTestCase):
    """Test structural tag generation for DeepSeekV3Detector."""

    def setUp(self):
        self.detector = DeepSeekV3Detector()

    def test_schema_always_included(self):
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_schema_always_included(tag)

    def test_at_least_one_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=True, stop_after_first=False
        )
        # DeepSeekV3 uses nested structure, check inner tag
        inner_false = tag_false["format"]["tags"][0]["content"]["tags"][0]
        inner_true = tag_true["format"]["tags"][0]["content"]["tags"][0]
        # The at_least_one is in the inner tags_with_separator
        # Actually, let's check the structure - it's nested
        self.assertIn("at_least_one", tag_false["format"]["tags"][0]["content"])
        self.assertFalse(tag_false["format"]["tags"][0]["content"]["at_least_one"])
        self.assertTrue(tag_true["format"]["tags"][0]["content"]["at_least_one"])

    def test_stop_after_first_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=True
        )
        self.assertFalse(tag_false["format"]["tags"][0]["content"]["stop_after_first"])
        self.assertTrue(tag_true["format"]["tags"][0]["content"]["stop_after_first"])

    def test_multiple_tools(self):
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )
        # DeepSeekV3 wraps all tools in a single outer tag
        self.assertIn("format", tag)
        # Check that inner tags contain both tools
        inner_tags = tag["format"]["tags"][0]["content"]["tags"]
        self.assertEqual(len(inner_tags), 2)

    def test_empty_parameters_handling(self):
        tool = self.get_empty_params_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assertIn("format", tag)
        # DeepSeekV3 has nested structure
        inner_tag = tag["format"]["tags"][0]["content"]["tags"][0]
        schema = inner_tag["content"]["json_schema"]
        self.assertEqual(schema, {})

    def test_structural_tag_matches_realistic_output(self):
        """Test that structural tag begin/end patterns match realistic model output."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Create realistic output: <｜tool▁calls▁begin｜><｜tool▁call▁begin｜>function<｜tool▁sep｜>get_weather\n```json\n{"city":"Dallas"}\n```<｜tool▁call▁end｜><｜tool▁calls▁end｜>
        realistic_output = (
            "<｜tool▁calls▁begin｜><｜tool▁call▁begin｜>function<｜tool▁sep｜>get_weather\n"
            '```json\n{"city":"Dallas"}\n```<｜tool▁call▁end｜><｜tool▁calls▁end｜>'
        )

        # Verify the structural tag's begin pattern matches the output
        outer_tag = tag["format"]["tags"][0]
        inner_tag = outer_tag["content"]["tags"][0]
        outer_begin = outer_tag["begin"]
        inner_begin = inner_tag["begin"]
        inner_end = inner_tag["end"]
        outer_end = outer_tag["end"]

        self.assertTrue(
            realistic_output.startswith(outer_begin + inner_begin),
            f"Realistic output should start with begin patterns. Outer: {outer_begin}, Inner: {inner_begin}, Output: {realistic_output}",
        )
        self.assertTrue(
            realistic_output.endswith(inner_end + outer_end),
            f"Realistic output should end with end patterns. Inner: {inner_end}, Outer: {outer_end}, Output: {realistic_output}",
        )

        # Verify tool name appears in the inner begin pattern
        self.assertIn(
            tool.function.name,
            inner_begin,
            f"Tool name '{tool.function.name}' should appear in inner begin pattern: {inner_begin}",
        )

        # Verify trigger appears in the realistic output
        triggers = tag["format"]["triggers"]
        self.assertTrue(
            any(trigger in realistic_output for trigger in triggers),
            f"At least one trigger should appear in realistic output. Triggers: {triggers}, Output: {realistic_output}",
        )


class TestDeepSeekV31Detector(StructuralTagFormatTestCase):
    """Test structural tag generation for DeepSeekV31Detector."""

    def setUp(self):
        self.detector = DeepSeekV31Detector()

    def test_schema_always_included(self):
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        # DeepSeekV31 has nested structure
        inner_tag = tag["format"]["tags"][0]["content"]["tags"][0]
        self.assertIn("content", inner_tag)
        self.assertIn("json_schema", inner_tag["content"])

    def test_at_least_one_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=True, stop_after_first=False
        )
        self.assertFalse(tag_false["format"]["tags"][0]["content"]["at_least_one"])
        self.assertTrue(tag_true["format"]["tags"][0]["content"]["at_least_one"])

    def test_stop_after_first_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=True
        )
        self.assertFalse(tag_false["format"]["tags"][0]["content"]["stop_after_first"])
        self.assertTrue(tag_true["format"]["tags"][0]["content"]["stop_after_first"])

    def test_multiple_tools(self):
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )
        inner_tags = tag["format"]["tags"][0]["content"]["tags"]
        self.assertEqual(len(inner_tags), 2)

    def test_empty_parameters_handling(self):
        tool = self.get_empty_params_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        inner_tag = tag["format"]["tags"][0]["content"]["tags"][0]
        schema = inner_tag["content"]["json_schema"]
        self.assertEqual(schema, {})

    def test_structural_tag_matches_realistic_output(self):
        """Test that structural tag begin/end patterns match realistic model output."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Create realistic output: <｜tool▁calls▁begin｜><｜tool▁call▁begin｜>get_weather<｜tool▁sep｜>{"city":"Dallas"}<｜tool▁call▁end｜><｜tool▁calls▁end｜>
        realistic_output = (
            "<｜tool▁calls▁begin｜><｜tool▁call▁begin｜>get_weather<｜tool▁sep｜>"
            '{"city":"Dallas"}<｜tool▁call▁end｜><｜tool▁calls▁end｜>'
        )

        # Verify the structural tag's begin pattern matches the output
        outer_tag = tag["format"]["tags"][0]
        inner_tag = outer_tag["content"]["tags"][0]
        outer_begin = outer_tag["begin"]
        inner_begin = inner_tag["begin"]
        inner_end = inner_tag["end"]
        outer_end = outer_tag["end"]

        self.assertTrue(
            realistic_output.startswith(outer_begin + inner_begin),
            f"Realistic output should start with begin patterns. Outer: {outer_begin}, Inner: {inner_begin}, Output: {realistic_output}",
        )
        self.assertTrue(
            realistic_output.endswith(inner_end + outer_end),
            f"Realistic output should end with end patterns. Inner: {inner_end}, Outer: {outer_end}, Output: {realistic_output}",
        )

        # Verify tool name appears in the inner begin pattern
        self.assertIn(
            tool.function.name,
            inner_begin,
            f"Tool name '{tool.function.name}' should appear in inner begin pattern: {inner_begin}",
        )

        # Verify trigger appears in the realistic output
        triggers = tag["format"]["triggers"]
        self.assertTrue(
            any(trigger in realistic_output for trigger in triggers),
            f"At least one trigger should appear in realistic output. Triggers: {triggers}, Output: {realistic_output}",
        )


class TestGptOssDetector(StructuralTagFormatTestCase):
    """Test structural tag generation for GptOssDetector."""

    def setUp(self):
        self.detector = GptOssDetector()

    def test_schema_always_included(self):
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        # GPT-OSS has two patterns per tool (reasoning enabled/disabled)
        self.assertEqual(len(tag["format"]["tags"]), 2)
        for tag_item in tag["format"]["tags"]:
            self.assertIn("content", tag_item)
            self.assertIn("json_schema", tag_item["content"])

    def test_at_least_one_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=True, stop_after_first=False
        )
        self.assertFalse(tag_false["format"]["at_least_one"])
        self.assertTrue(tag_true["format"]["at_least_one"])

    def test_stop_after_first_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=True
        )
        self.assertFalse(tag_false["format"]["stop_after_first"])
        self.assertTrue(tag_true["format"]["stop_after_first"])

    def test_multiple_tools(self):
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )
        # GPT-OSS has 2 patterns per tool
        self.assertEqual(len(tag["format"]["tags"]), 4)

    def test_empty_parameters_handling(self):
        tool = self.get_empty_params_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assertEqual(len(tag["format"]["tags"]), 2)
        for tag_item in tag["format"]["tags"]:
            schema = tag_item["content"]["json_schema"]
            self.assertEqual(schema, {})

    def test_structural_tag_matches_realistic_output(self):
        """Test that structural tag begin/end patterns match realistic model output."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Create realistic output: <|start|>assistant<|channel|>commentary to=functions.get_weather<|constrain|>json<|message|>{"city":"Dallas"}<|call|>
        # Note: GPT-OSS detector's has_tool_call() checks for "<|start|>assistant<|channel|>commentary"
        realistic_output = '<|start|>assistant<|channel|>commentary to=functions.get_weather<|constrain|>json<|message|>{"city":"Dallas"}<|call|>'

        # GPT-OSS has two patterns per tool, check if either matches
        tag_items = tag["format"]["tags"]
        found_match = False
        for tag_item in tag_items:
            begin = tag_item["begin"]
            end = tag_item["end"]
            if realistic_output.startswith(begin):
                found_match = True
                # End is empty for GPT-OSS, so just check begin
                break

        self.assertTrue(
            found_match,
            f"Realistic output should match one of the structural tag patterns. Output: {realistic_output}",
        )

        # For GPT-OSS, verify tool name appears in at least one tag's begin pattern
        tag_items = tag["format"]["tags"]
        tool_name_found = any(
            tool.function.name in tag_item["begin"] for tag_item in tag_items
        )
        self.assertTrue(
            tool_name_found,
            f"Tool name '{tool.function.name}' should appear in at least one tag's begin pattern",
        )

        # Verify trigger appears in the realistic output
        triggers = tag["format"]["triggers"]
        self.assertTrue(
            any(trigger in realistic_output for trigger in triggers),
            f"At least one trigger should appear in realistic output. Triggers: {triggers}, Output: {realistic_output}",
        )


class TestKimiK2Detector(StructuralTagFormatTestCase):
    """Test structural tag generation for KimiK2Detector."""

    def setUp(self):
        self.detector = KimiK2Detector()

    def test_schema_always_included(self):
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_schema_always_included(tag)

    def test_at_least_one_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=True, stop_after_first=False
        )
        self.assertFalse(tag_false["format"]["at_least_one"])
        self.assertTrue(tag_true["format"]["at_least_one"])

    def test_stop_after_first_parameter(self):
        tool = self.get_simple_tool()
        tag_false = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        tag_true = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=True
        )
        self.assertFalse(tag_false["format"]["stop_after_first"])
        self.assertTrue(tag_true["format"]["stop_after_first"])

    def test_multiple_tools(self):
        tools = [self.get_simple_tool(), self.get_complex_tool()]
        tag = self.detector.build_structural_tag(
            tools=tools, at_least_one=False, stop_after_first=False
        )
        self.assert_structural_tag_structure(tag, expected_tools_count=2)

    def test_empty_parameters_handling(self):
        tool = self.get_empty_params_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )
        self.assert_structural_tag_structure(tag, expected_tools_count=1)
        schema = tag["format"]["tags"][0]["content"]["json_schema"]
        self.assertEqual(schema, {})

    def test_structural_tag_matches_realistic_output(self):
        """Test that structural tag begin/end patterns match realistic model output."""
        tool = self.get_simple_tool()
        tag = self.detector.build_structural_tag(
            tools=[tool], at_least_one=False, stop_after_first=False
        )

        # Create realistic output: <|tool_calls_section_begin|><|tool_call_begin|>functions.get_weather:0<|tool_call_argument_begin|>{"city":"Dallas"}<|tool_call_end|><|tool_calls_section_end|>
        # Note: KimiK2 uses index in the format, so we need to check with index 0
        realistic_output = '<|tool_calls_section_begin|><|tool_call_begin|>functions.get_weather:0<|tool_call_argument_begin|>{"city":"Dallas"}<|tool_call_end|><|tool_calls_section_end|>'

        # Verify the structural tag's begin pattern matches the output
        tag_item = tag["format"]["tags"][0]
        begin = tag_item["begin"]
        end = tag_item["end"]

        self.assertTrue(
            realistic_output.startswith(begin),
            f"Realistic output should start with begin pattern. Begin: {begin}, Output: {realistic_output}",
        )
        self.assertTrue(
            realistic_output.endswith(end),
            f"Realistic output should end with end pattern. End: {end}, Output: {realistic_output}",
        )

        # Verify tool name appears in the begin pattern (may include index for KimiK2)
        # KimiK2 format includes index like "functions.get_weather:0"
        tool_name_base = tool.function.name
        self.assertTrue(
            tool_name_base in begin or f"functions.{tool_name_base}" in begin,
            f"Tool name '{tool_name_base}' should appear in begin pattern: {begin}",
        )

        # Verify trigger appears in the realistic output
        triggers = tag["format"]["triggers"]
        self.assertTrue(
            any(trigger in realistic_output for trigger in triggers),
            f"At least one trigger should appear in realistic output. Triggers: {triggers}, Output: {realistic_output}",
        )


# Note: Glm4MoeDetector, PythonicDetector, Step3Detector, and MinimaxM2Detector
# return False for supports_structural_tag() and raise NotImplementedError
# for build_structural_tag(), so they are not tested here.


if __name__ == "__main__":
    unittest.main()
